module.exports=function(o,c){"use strict";var n={};function __webpack_require__(c){if(n[c]){return n[c].exports}var f=n[c]={i:c,l:false,exports:{}};o[c].call(f.exports,f,f.exports,__webpack_require__);f.l=true;return f.exports}__webpack_require__.ab=__dirname+"/";function startup(){return __webpack_require__(706)}return startup()}({706:function(o){const c=Symbol("arg flag");function arg(o,{argv:n,permissive:f=false,stopAtPositional:_=false}={}){if(!o){throw new Error("Argument specification object is required")}const h={_:[]};n=n||process.argv.slice(2);const w={};const k={};for(const n of Object.keys(o)){if(!n){throw new TypeError("Argument key cannot be an empty string")}if(n[0]!=="-"){throw new TypeError(`Argument key must start with '-' but found: '${n}'`)}if(n.length===1){throw new TypeError(`Argument key must have a name; singular '-' keys are not allowed: ${n}`)}if(typeof o[n]==="string"){w[n]=o[n];continue}let f=o[n];let _=false;if(Array.isArray(f)&&f.length===1&&typeof f[0]==="function"){const[o]=f;f=((c,n,f=[])=>{f.push(o(c,n,f[f.length-1]));return f});_=o===Boolean||o[c]===true}else if(typeof f==="function"){_=f===Boolean||f[c]===true}else{throw new TypeError(`Type missing or not a function or valid array type: ${n}`)}if(n[1]!=="-"&&n.length>2){throw new TypeError(`Short argument keys (with a single hyphen) must have only one character: ${n}`)}k[n]=[f,_]}for(let o=0,c=n.length;o<c;o++){const c=n[o];if(_&&h._.length>0){h._=h._.concat(n.slice(o));break}if(c==="--"){h._=h._.concat(n.slice(o+1));break}if(c.length>1&&c[0]==="-"){const _=c[1]==="-"||c.length===2?[c]:c.slice(1).split("").map(o=>`-${o}`);for(let c=0;c<_.length;c++){const b=_[c];const[$,t]=b[1]==="-"?b.split("=",2):[b,undefined];let E=$;while(E in w){E=w[E]}if(!(E in k)){if(f){h._.push(b);continue}else{const o=new Error(`Unknown or unexpected option: ${$}`);o.code="ARG_UNKNOWN_OPTION";throw o}}const[T,q]=k[E];if(!q&&c+1<_.length){throw new TypeError(`Option requires argument (but was followed by another short argument): ${$}`)}if(q){h[E]=T(true,E,h[E])}else if(t===undefined){if(n.length<o+2||n[o+1].length>1&&n[o+1][0]==="-"){const o=$===E?"":` (alias for ${E})`;throw new Error(`Option requires argument: ${$}${o}`)}h[E]=T(n[o+1],E,h[E]);++o}else{h[E]=T(t,E,h[E])}}}else{h._.push(c)}}return h}arg.flag=(o=>{o[c]=true;return o});arg.COUNT=arg.flag((o,c,n)=>(n||0)+1);o.exports=arg}});